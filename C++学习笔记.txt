1.Qt信号槽参数的传递方式：
	信号槽直连时，和函数传递一样，队列连接时，先对参数进行转储，然后传递，但是非内置类型，需要注册
2.对象在栈申明后，什么时候释放：
	对象申明后，在遇到“}”后释放，编译器不会判断后续有无使用而释放
3.Qt事件参数的传递方式：
	qApp->sendEvent(ui->graphicsView,&xx);
	qApp->postEvent(ui->graphicsView,aa);
	Qt不会进行任何参数转储
4.Qt既然有了信号槽，为什么还要有事件：
	信号槽是在绑定的时候指定同步或异步，事件是在发送的时候指定同步或异步
5.什么是深赋值：
	对象的内存拷贝
6.什么是浅赋值：
	对象的指针拷贝
7.什么是隐性共享：
	在赋值的时候，进行浅赋值，引用计数+1，进行修改时，引用计数-1，进行内存拷贝后修改，引用计数=0时，释放内存
8.单元加载和释放时执行的函数(gcc)：
	__attribute__((constructor)) void Initialize();
	__attribute__((destructor)) void Cleanup();
9.在隐性共享中，[]和at取值方式，那种效率高：
	[]的方式要判断是读还是写，at不需要，所以at的效率更高
10.Qt各容器的区别：
	QLinkedList<T> 基于链表实现，元素存储空间不连续，提供基于index的对元素的快速访问，有较多插入操作，删除时建议使用。 类似于QList，但是一般通过迭代器访问元素，而不是index。
	链表，添加删除操作多，读取少的情况下使用
	QVector<T> 存储空间连续，插入操作性能不理想，访问性能佳。 数组的区别在于:可以随时改变大小。
	数组，读取多，插入删除少的情况下使用
	QList<T> 集合了QLinkedList<T>和QVector<T>的优点 具有很好的扩展性，比如QStringList。 QList::append()：后端插入 QList::prepend(): 前端插入 QList::insert()：按index插入
	比较通用，中和
	QStack<T> 继承于QVector，提供LIFO功能。 新增push(), pop(), 和 top()等。
	栈，对最后元素频繁操作的情况下使用
	QQueue<T> 继承于QList，提供FIFO功能。 新增enqueue(), dequeue(), and head().
	队列，对第一个频繁操作的情况下使用
	QSet<T> 提供对不可重复的集合的快速查找。
	数据基本固定，查询很多的情况下使用
	QMap<Key, T> 按照键排序，存储键值对。
	QMultiMap<Key, T> 与QMap不同在于，一键可以对应多值。
	QHash<Key, T> 与QMap类似，不同之处在于，对于元素查找，利用hash函数进行，并且元素并没有按照键值排序。
	QMultiHash<Key, T> 与QHash的不同之处在于，可以一键对应多值。
11.Timer是否可重入：
	单线程情况下，不会重入，除非内部进行消息循环处理,Qt下，即使使用QEventLoop阻塞，也不会造成重入，Delphi下如果使用Application.ProcessMessages;会重入
12.C++如何申明类成员函数：
	typedef void (A::*xxx)(int);
13.C++中强制类型转换的方式：
	支持C系列的转换(type)xxx；
	类似C系列，什么都不检查：reinterpret_cast
	编译期间进行检查：static_cast
	编译期间+运行期间进行检查：dynamic_cast，运行期间转换失败，返回NULL
	打破常量不能修改的转换：const_cast
14.Qt中postEvent中传递指针，对象何时释放
	Qt会在分发完成后，自动释放，不用手动释放，但是sendEvent需要自己释放
15.Qt中QThread中的run函数，是否运行完就结束
	run中调用了消息循环的exec，不接收到quit是不会跳出的
16.Qt中QObject::movetothread(xx)后，槽函数在哪个线程执行
	槽函数在xx线程中执行
17.Qt中直连和队列连接时，槽函数在哪个线程执行
	直接连接(Direct Connection)
		当信号发射时，槽函数将直接被调用。
		无论槽函数所属对象在哪个线程，槽函数都在发射信号的线程内执行。
	队列连接(Queued Connection)
		当控制权回到接受者所依附线程的事件循环时，槽函数被调用。
		槽函数在接收者所依附线程执行。
18.C++模板是否可以定义在局部变量内部
	模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不能在main函数中声明或定义一个模板。
19.C++函数模板和类模板的区别
	函数模板针对仅参数类型不同的函数；
	类模板针对仅数据成员和成员函数类型不同的类。
20.C++函数模板的定义格式
	template <class 形参名，class 形参名，......> 返回类型 函数名(参数列表)
	{
		函数体
	}
21.C++类模板的定义格式
	template<class  形参名，class 形参名，…>   class 类名 
	{ ... };
22.C++的模板的非类型形参
	<1>非类型模板形参：模板的非类型形参也就是内置类型形参，如template<class T, int a> class B{};其中int a就是非类型的模板形参。
	<2>非类型形参在模板定义的内部是常量值，也就是说非类型形参在模板的内部是常量。
	<3>非类型模板的形参只能是整型，指针和引用，像double，String, String **这样的类型是不允许的。但是double &，double *，对象的引用或指针是正确的。
	<4>调用非类型模板形参的实参必须是一个常量表达式，即他必须能在编译时计算出结果。
	<5>注意：任何局部对象，局部变量，局部对象的地址，局部变量的地址都不是一个常量表达式，都不能用作非类型模板形参的实参。全局指针类型，全局变量，全局对象也不是一个常量表达式，不能用作非类型模板形参的实参。
	<6>全局变量的地址或引用，全局对象的地址或引用const类型变量是常量表达式，可以用作非类型模板形参的实参。
	<7>sizeof表达式的结果是一个常量表达式，也能用作非类型模板形参的实参。
	<8>当模板的形参是整型时调用该模板时的实参必须是整型的，且在编译期间是常量，比如template <class T, int a> class A{};如果有int b，这时A<int, b> m;将出错，因为b不是常量，如果const int b，这时A<int, b> m;就是正确的，因为这时b是常量。
	<9>非类型形参一般不应用于函数模板中，比如有函数模板template<class T, int a> void h(T b){}，若使用h(2)调用会出现无法为非类型形参a推演出参数的错误，对这种模板函数可以用显示模板实参来解决，如用h<int, 3>(2)这样就把非类型形参a设置为整数3。显示模板实参在后面介绍。
	<10>非类型模板形参的形参和实参间所允许的转换
		a.允许从数组到指针，从函数到指针的转换。如：template <int *a> class A{}; int b[1]; A<b> m;即数组到指针的转换
		b.const修饰符的转换。如：template<const int *a> class A{}; int b; A<&b> m;   即从int *到const int *的转换。
		c.提升转换。如：template<int a> class A{}; const short b=2; A<b> m; 即从short到int 的提升转换
		d.整值转换。如：template<unsigned int a> class A{};   A<3> m; 即从int 到unsigned int的转换。
		e.常规转换。
23.C++函数模板显式调用
	xxx<>();
24.C++模板的默认模板类型形参
	只能用于类模板，不能用于函数模板
	格式为：template<class T1, class T2=int> class A{};
	默认值开了头，后面的就必须都有默认值，如template<class T1=int, class T2>class A{};就是错误的
	在类模板的外部定义类中的成员时template 后的形参表应省略默认的形参类型。比如template<class  T1, class T2=int> class A{public: void h();}; 定义方法为template<class T1,class T2> void A<T1,T2>::h(){}。
25.C++模板中class和typename的区别
	一般情况下，毫无区别，只是在嵌套使用的时候，必须加typename关键字，如：
	template <class T> void xxx(typename T::xx a)
	{
    		a;
	}
	T::xx前必须加typename，
	但是在基类和成员初始化中不能加，如：
	template<class T>
	class xxx:public Base<T>::sss //不加
	｛
		xxx():Base<T>::sss() //不加
	}
26.C++的初始化列表的格式
	xxx(参数列表):a(),b() {};
27.C++类和结构体的区别
	结构体的默认是公有，类的默认是私有
28.C++匿名函数(lambda函数,lambda表达式)
	[capture](parameters)->return-type{body}
29.atexit函数的作用
	注册N(<=32)个在程序退出时执行的函数，格式为void xxx(void)，按注册顺序的反序执行，_exit和_Exit不会调用。
30.C++运算符重载
	A& operator =(A & a){ qDebug()<<"aa"; return a;}
	但是此重载，只针对=符号，在参数传递的时候，无效，如果要针对参数传递，需要重载构造函数
	A(A& a){qDebug()<<"aa";}
	引用计数的实现方式必须注意重载=和构造函数
31.C++类静态成员变量
	类静态成员变量所有对象中只存在一份
	不能在非静态成员函数中操作
	初始化方式:type classname::valuename = N;
	静态成员是类所有的对象的共享的成员，而不是某个对象的成员。它在对象中不占用存储空间，这个属性为整个类所共有，不属于任何一个具体对象
32.C++类静态成员函数
	静态函数成员必须通过对象名来访问非静态数据成员。
	静态成员函数在类外实现时候无须加static关键字，否则是错误的。
	静态成员函数没有this指针，它不能返回非静态成员，因为除了对象会调用它外，类本身也可以调用。
33.C++类静态成员
	出现在类体外的函数定义不能指定关键字static；
	静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数；
	非静态成员函数可以任意地访问静态成员函数和静态数据成员；
	静态成员函数不能访问非静态成员函数和非静态数据成员；
	由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；
	调用静态成员函数，可以用成员访问操作符(.)和(->)为一个类的对象或指向类对象的指针调用静态成员函数，
	当同一类的所有对象使用一个量时，对于这个共用的量，可以用静态数据成员变量，这个变量对于同一类的所有的对象都取相同的值。
	静态成员变量只能被静态成员函数调用。
	静态成员函数也是由同一类中的所有对象共用。只能调用静态成员变量和静态成员函数。
34.Qt中View和Widget的命名区别
	xxxView是可以和Model绑定，xxxWidget继承于xxxView，私有化setModel
35.Qt中改变单元格状态或编辑控件
	子类化QItemDelegate，然后view->setItemDelegate(sa);
36.编程语言中的调用约定
	stdcall:参数从右到左开始压栈,函数本身清除了栈上的参数，不支持可变参数个数的函数，下划线开头，函数名，然后@符号，最后是参数的总byte数。如：int f(int a, double b )，名字为_f@12
	cdecl:参数从右到左开始压栈,调用者来清除栈上的参数，支持可变参数个数的函数，加下划线前缀，如：_func
	fastcall:参数从右到左开始压栈,第一个参数和第二个参数使用寄存器，调用者来清除栈上的参数，不支持可变参数个数的函数，以@开头，其他和__stdcall一样。如：@f@12
	其他还有register,pascal,safecall等约定，不太常用



























