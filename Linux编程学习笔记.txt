一：编译器：
arm-none-linux-gnueabi是基于linux系统的，http://blog.csdn.net/ee230/article/details/41513957的博客上有地址，是百度云盘的
arm-none-gnueabi是基于裸板的，在Launchpad可以下载
二：调试器：
GDB：用主机自带的gcc编译，编译后放到工具链的bin里面，覆盖原先的
GDBServer：用交叉编译链编译，在GDB文件夹下的GDBServer文件夹下
GDBServer发送到开发板，每次手动运行，为了自动进行调试，编写以下sh脚本：
×××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××
#!/bin/sh

while true
do
	/gdbserver 192.168.1.126:7890 /mnt/home/xhxtt/cuiyd/clyy/bin/Debug/clyy
	wait
done
×××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××
用xxx.sh &的方式运行
三：IDE：
CodeBlocks:汉化方法：/usr/share/codeblocks下新建locale文件夹，再新建zh_CN文件夹，把codeblocks.mo放到里面

u-boot：
print：输出当前配置信息
setenv：设置配置
saveenv：保存配置
bootm：第一个参数是引导位置
nand erase:格式化nand flash
tftp 22200000 uImage
从设置的serverip的地方下载uImage到内存的22200000位置，22200000是个指定的位置，尽量考后，避免被使用
nand write 22200000 400000 200000
将内存22200000地址的的数据，写入到flash的400000的位置，大小是200000，22200000同上tftp时的指定，400000需要查看linux内核文件夹下的arch/arm/mach-芯片类型/board-芯片后缀ek.c文件的NAND flash分区代码，修改分区，或者修改此地参数，大小就是tftp接收的大小，可以大，不能小，最大不能超过分区大小
tftp 21100000 jffs2.jffs2
同下载uImage，21100000的含义和22200000相同
nand write.jffs2 21100000 800000 400000
参数含义与写入uImage相同
设置bootcmd变量：setenv bootcmd nand read 22200000 400000 200000 /; bootm 22200000
read后的三个参数同write uImage的参数，含义略有不同：read：读取flash 400000位置的大小为200000的数据到内存22200000，bootm后为内存引导地址
四：编译linux内核：
1：修改flash分区：arch/arm/mach-芯片类型/board-芯片后缀ek.c文件的NAND flash分区代码

/*
 * NAND flash
 */
static struct mtd_partition __initdata ek_nand_partition[] = {
	{
		.name	= "Bootloader",
		.offset	= 0,
		.size	= 4*1024*1024,
	},
	{
		.name	= "Kernel",
		.offset	= 4*1024*1024,
		.size	= MTDPART_SIZ_FULL,
	},
	{
		.name	= "jffs2",
		.offset	= 8*1024*1024,
		.size	= MTDPART_SIZ_FULL,
	},
};

2：修改晶震：同上文件，at91_initialize函数为设置晶震频率，不同芯片，具体看芯片文档，且函数名可能不是ek_init_early，但是会有__init，后三据设置串口，不修改，可能启动内核时输出乱码
static void __init ek_init_early(void)
{
	/* Initialize processor: 16.367 MHz crystal 
	at91_initialize(16367660);*/
	/* Initialize processor: 18.432 MHz crystal  demo board is 16.367 MHZ*/
	at91_initialize(18432000);

	/* DGBU on ttyS0. (Rx & Tx only) */
	at91_register_uart(0, 0, 0);

	/* USART0 com1 on ttyS1. (Rx, Tx, RTS, CTS) */
	at91_register_uart(AT91SAM9263_ID_US0, 1, ATMEL_UART_CTS | ATMEL_UART_RTS);
	/* USART1 com2 on ttyS2. (Rx, Tx) */
	at91_register_uart(AT91SAM9263_ID_US1, 2,0);
	/* USART2 com3  on ttyS3. (Rx, Tx) */
	at91_register_uart(AT91SAM9263_ID_US2, 3,0);

	/* set serial console to ttyS0 (ie, DBGU) 
	at91_set_serial_console(0);*/
}

3：配置内核：其他的自己看，但是在选择芯片的时候，务必选中下方一个带Kit的选项，否则会报告no machine record defined，如果内核内部有定义，在include/asm-arm/mach-types.h中，如过无，看看u-boot，加进来，或者编译内核时勾上
make menuconfig
Kernel hacking --->
[*] Kernel debugging
[*] Kernel low-level debugging functions
[*] Kernel low-level debugging messages via S3C UART
输出
Starting kernel ... Uncompressing Linux................................................................................................................................... done, booting the kernel. Error: unrecognized/unsupported machine ID (r1 = 0x0000016a). Available machine support: ID (hex) NAME 000007cf FriendlyARM Mini2440 development board Please check your kernel config and/or bootloader.
000007cf就是Machine ID，双方一致就OK，网上说的注释arch/arm/kernel/vmlinux.lds的断言函数，那是扯淡
五：迁移驱动：
1.新内核去掉了__devexit，__devinitdata，__devinit，__devexit_p四个宏定义，如果有的话，自己加上即可
#define __devexit
#define __devinitdata
#define __devinit
#define __devexit_p
2.新内核的驱动结构发生变化，以前为：
static struct file_operations adc_fops = {
	.owner	=	THIS_MODULE,
	.open	=	adc_open,
	.write	=	adc_write,
	.read	=	adc_read,
	.release=	adc_release,
	.ioctl	=	adc_ioctl,
};
现在ioctl变成两个unlocked_ioctl和compat_ioctl;compat_ioctl被使用在用户空间为32位模式，而内核运行在64位模式时。这时候，需要将64位转成32位。一般用unlocked_ioctl取代
3.IRQF_SAMPLE_RANDOM中断标记被取消
六：linux驱动开发环境搭建：
1.下载linux内核
2.编译内核（类似裁剪）
3.主机编写驱动文件和Makefile
Makefile类似于下：
××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××
ifneq ($(KERNELRELEASE),)
obj-m :=at91_keypad.o
obj-m +=at91_adc.o
#at91_adc-objs := at91_adc.o
else
CROSS_COMPILE := /home/xhxtt/ftp/arm-2014.05/bin/arm-none-linux-gnueabi-gcc
KDIR := /home/xhxtt/ftp/linux-3.18
all:
	$(MAKE) ARCH=arm CROSS_COMPILE=/home/xhxtt/ftp/arm-2014.05/bin/arm-none-linux-gnueabi- -C $(KDIR) M=$(shell pwd) modules
endif
××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××
CROSS_COMPILE 编译器
KDIR := 内核源码
七：linux文件系统：
编译busybox，复制到制定的文件夹下，具体参照jffs2文件夹，需要注意的是，要将编译器的.so文件复制到/lib里面，主要包括:$编译器/arm-none-linux-gnueabi/libc/lib下和$编译器/arm-none-linux-gnueabi/libc/usr/lib的所有.so，最好分别复制到/lib和/usr/lib
libthread_db.so是GDBServer需要的链接库
readelf -d xxx   可以查看xxx的依赖库
mkfs.jffs2 -e 0x20000 -l -s 0x800 -p -n -d jffs2 -o jffs2.jffs2
将jffs2文件夹制作成jffs2.jffs2的镜像文件
-e, --eraseblock=SIZE   设定擦除块的大小为(默认: 64KiB)
-l, --little-endian             指定使用小端格式
-s, --pagesize=SIZE   节点页大小(默认: 4KiB)
-p, --pad[=SIZE]        用16進制表示所要輸出檔案的大小，也就是root.jffs2的size。很重要的是,為了不浪費flash空間,這個值最好符合flash driver的區塊大小。如果不足则使用0xff来填充补满。
-n, --no-cleanmarkers   指明不添加清楚标记（nand flash 有自己的校检块，存放相关的信息。）
-r, -d, --root=DIR       指定要做成image的源資料夾.(默认：当前文件夹)
-o, --output=FILE         指定輸出image檔案的文件名.(default: stdout)

















